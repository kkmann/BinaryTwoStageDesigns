<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Inference · BinaryTwoStageDesigns</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BinaryTwoStageDesigns</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Welcome!</a></li><li><a class="toctext" href="sample_space.html">Sample Spaces</a></li><li><a class="toctext" href="parameters.html">Design Parameters</a></li><li><a class="toctext" href="designs.html">Two-Stage Designs</a></li><li><a class="toctext" href="optimal_designs.html">Finding Optimal Designs</a></li><li class="current"><a class="toctext" href="inference.html">Inference</a><ul class="internal"><li><a class="toctext" href="#Point-estimation-1">Point estimation</a></li><li><a class="toctext" href="#P-values-1">P values</a></li><li><a class="toctext" href="#Confidence-intervals-1">Confidence intervals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="inference.html">Inference</a></li></ul><a class="edit-page" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/master"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Inference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Inference-1" href="#Inference-1">Inference</a></h1><ul><li><a href="inference.html#Inference-1">Inference</a></li><ul><li><a href="inference.html#Point-estimation-1">Point estimation</a></li><ul><li><a href="inference.html#Maximum-likelihood-estimator-1">Maximum likelihood estimator</a></li><li><a href="inference.html#Unbiased-estimator-1">Unbiased estimator</a></li><li><a href="inference.html#Optimal-compatible-estimator-1">Optimal compatible estimator</a></li></ul><li><a href="inference.html#P-values-1">P values</a></li><li><a href="inference.html#Confidence-intervals-1">Confidence intervals</a></li><ul><li><a href="inference.html#Naive-Clopper-Pearson-confidence-interval-1">Naive Clopper-Pearson confidence interval</a></li><li><a href="inference.html#Clopper-Pearson-confidence-interval-1">Clopper-Pearson confidence interval</a></li><li><a href="inference.html#Minimum-mean-width-confidence-interval-1">Minimum mean width confidence interval</a></li></ul></ul></ul><h2><a class="nav-anchor" id="Point-estimation-1" href="#Point-estimation-1">Point estimation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.Estimator" href="#BinaryTwoStageDesigns.Estimator"><code>BinaryTwoStageDesigns.Estimator</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Estimator</code></pre><p>Abstract base type for all estimators.</p></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.estimate-Union{Tuple{BinaryTwoStageDesigns.Estimator,T,T}, Tuple{T}} where T&lt;:Integer" href="#BinaryTwoStageDesigns.estimate-Union{Tuple{BinaryTwoStageDesigns.Estimator,T,T}, Tuple{T}} where T&lt;:Integer"><code>BinaryTwoStageDesigns.estimate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">estimate{T&lt;:Integer}(estimator::Estimator, x1::T, x2::T)</code></pre><p>Estimate the response rate from observed x1 and x2.</p><p><strong>Parameters</strong></p><table><tr><th>Parameter</th><th>Description</th></tr><tr><td>estimator</td><td>any BinaryTwoStageDeisgnEstimator object</td></tr><tr><td>x1</td><td>stage-one responses</td></tr><tr><td>x2</td><td>stage-two responses</td></tr></table><p><strong>Return Value</strong></p><p>Real, estimated response rate.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ss = SimpleSampleSpace(10:25, 100, n2min = 5)
julia&gt; interimsamplesize(ss)
julia&gt; design = getoptimaldesign(15, params, solver = Gurobi.GurobiSolver())
julia&gt; est = MLE(design)
julia&gt; estimate(est, 0, 0)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.bias-Union{Tuple{BinaryTwoStageDesigns.Estimator,T}, Tuple{T}} where T&lt;:Real" href="#BinaryTwoStageDesigns.bias-Union{Tuple{BinaryTwoStageDesigns.Estimator,T}, Tuple{T}} where T&lt;:Real"><code>BinaryTwoStageDesigns.bias</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">bias{T&lt;:Real}(estimator::Estimator, p::T)</code></pre><p>Bias of <code>estimator</code> given response rate <code>p</code>.</p><p><strong>Parameters</strong></p><table><tr><th>Parameter</th><th>Description</th></tr><tr><td>estimator</td><td>any BinaryTwoStageDeisgnEstimator object</td></tr><tr><td>p0</td><td>upper boundary of null hypothesis</td></tr></table><p><strong>Return Value</strong></p><p>Real, bias given <code>p</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ss = SimpleSampleSpace(10:25, 100, n2min = 5)
julia&gt; interimsamplesize(ss)
julia&gt; design = getoptimaldesign(15, params, solver = Gurobi.GurobiSolver())
julia&gt; est = MLE(design)
julia&gt; bias(est, .3)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.rmse-Union{Tuple{BinaryTwoStageDesigns.Estimator,T}, Tuple{T}} where T&lt;:Real" href="#BinaryTwoStageDesigns.rmse-Union{Tuple{BinaryTwoStageDesigns.Estimator,T}, Tuple{T}} where T&lt;:Real"><code>BinaryTwoStageDesigns.rmse</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">rmse{T&lt;:Real}(estimator::Estimator, p::T)</code></pre><p>Root mean squared error of <code>estimator</code> given response rate <code>p</code>.</p><p><strong>Parameters</strong></p><table><tr><th>Parameter</th><th>Description</th></tr><tr><td>estimator</td><td>any BinaryTwoStageDeisgnEstimator object</td></tr><tr><td>p0</td><td>upper boundary of null hypothesis</td></tr></table><p><strong>Return Value</strong></p><p>Real, RMSE given <code>p</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ss = SimpleSampleSpace(10:25, 100, n2min = 5)
julia&gt; interimsamplesize(ss)
julia&gt; design = getoptimaldesign(15, params, solver = Gurobi.GurobiSolver())
julia&gt; est = MLE(design)
julia&gt; rmse(est, .3)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><h3><a class="nav-anchor" id="Maximum-likelihood-estimator-1" href="#Maximum-likelihood-estimator-1">Maximum likelihood estimator</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.MLEstimator-Tuple{BinaryTwoStageDesigns.Design}" href="#BinaryTwoStageDesigns.MLEstimator-Tuple{BinaryTwoStageDesigns.Design}"><code>BinaryTwoStageDesigns.MLEstimator</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">MLEstimator(design::TD) where {TD&lt;:Design}</code></pre><p>Create maximum likelihood estimator for response rate under given design.</p></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><h3><a class="nav-anchor" id="Unbiased-estimator-1" href="#Unbiased-estimator-1">Unbiased estimator</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.RBEstimator-Tuple{BinaryTwoStageDesigns.Design}" href="#BinaryTwoStageDesigns.RBEstimator-Tuple{BinaryTwoStageDesigns.Design}"><code>BinaryTwoStageDesigns.RBEstimator</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">RBEstimator(design::TD) where {TD&lt;:Design}</code></pre><p>Create unbiased estimator for response rate <code>p</code> see also:</p><blockquote><p>Kunzmann K, Kieser M. Point estimation and p‐values in phase II adaptive two‐stage designs with a binary endpoint. Statistics in medicine. 2017 Mar 15;36(6):971-84.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><h3><a class="nav-anchor" id="Optimal-compatible-estimator-1" href="#Optimal-compatible-estimator-1">Optimal compatible estimator</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.OCEstimator-Union{Tuple{BinaryTwoStageDesigns.Design,TS}, Tuple{TS}} where TS&lt;:MathProgBase.SolverInterface.AbstractMathProgSolver" href="#BinaryTwoStageDesigns.OCEstimator-Union{Tuple{BinaryTwoStageDesigns.Design,TS}, Tuple{TS}} where TS&lt;:MathProgBase.SolverInterface.AbstractMathProgSolver"><code>BinaryTwoStageDesigns.OCEstimator</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">OCEstimator{TS&lt;:MathProgBase.AbstractMathProgSolver}(
  design::Design,
  solver::TS;
  prior::Function = jeffreysprior(design),
  k = 100
)</code></pre><p>Create compatible estimator minimizing expected MSE for response rate <code>p</code> see also:</p><blockquote><p>Kunzmann K, Kieser M. Point estimation and p‐values in phase II adaptive two‐stage designs with a binary endpoint. Statistics in medicine. 2017 Mar 15;36(6):971-84.</p></blockquote><p><strong>Parameters</strong></p><table><tr><th>Parameter</th><th>Description</th></tr><tr><td>design</td><td>Design</td></tr><tr><td>solver</td><td>MathProgBase solver, must support quadratic expressions</td></tr><tr><td>prior</td><td>weight function for MSE values at different <code>p</code>, must be of form <code>f(p::Real)::Real</code></td></tr><tr><td>k</td><td>number of equally spaced grid-points for evaluation of MSE and prior</td></tr></table></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><h2><a class="nav-anchor" id="P-values-1" href="#P-values-1">P values</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.pvalue-Union{Tuple{BinaryTwoStageDesigns.Estimator,T1,T1,T2}, Tuple{T1}, Tuple{T2}} where T2&lt;:Real where T1&lt;:Integer" href="#BinaryTwoStageDesigns.pvalue-Union{Tuple{BinaryTwoStageDesigns.Estimator,T1,T1,T2}, Tuple{T1}, Tuple{T2}} where T2&lt;:Real where T1&lt;:Integer"><code>BinaryTwoStageDesigns.pvalue</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">p{T1&lt;:Integer, T2&lt;:Real}(estimator::Estimator, x1::T1, x2::T1, p0::T2)</code></pre><p>Compute the p value after observing (x1, x2) for null hypothesis H0: p &lt;= p0 with respect to ordering induced by <code>estimator</code>.</p><p><strong>Parameters</strong></p><table><tr><th>Parameter</th><th>Description</th></tr><tr><td>estimator</td><td>any BinaryTwoStageDeisgnEstimator object</td></tr><tr><td>x1</td><td>stage-one responses</td></tr><tr><td>x2</td><td>stage-two responses</td></tr><tr><td>p0</td><td>upper boundary of null hypothesis</td></tr></table><p><strong>Return Value</strong></p><p>Real, p value.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ss = SimpleSampleSpace(10:25, 100, n2min = 5)
julia&gt; interimsamplesize(ss)
julia&gt; design = getoptimaldesign(15, params, solver = Gurobi.GurobiSolver())
julia&gt; est = MLE(design)
julia&gt; p(est, 0, 0, .2)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.incompatibleoutcomes-Tuple{BinaryTwoStageDesigns.Estimator}" href="#BinaryTwoStageDesigns.incompatibleoutcomes-Tuple{BinaryTwoStageDesigns.Estimator}"><code>BinaryTwoStageDesigns.incompatibleoutcomes</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">incompatibleoutcomes(estimator::Estimator)</code></pre><p>Find outcomes where the induced p value implies different decision than the underlying design</p><p><strong>Parameters</strong></p><table><tr><th>Parameter</th><th>Description</th></tr><tr><td>estimator</td><td>any BinaryTwoStageDeisgnEstimator object</td></tr></table><p><strong>Return Value</strong></p><p>Array with respective outcomes</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ss = SimpleSampleSpace(10:25, 100, n2min = 5)
julia&gt; interimsamplesize(ss)
julia&gt; design = getoptimaldesign(15, params, solver = Gurobi.GurobiSolver())
julia&gt; est = MLE(design)
julia&gt; incompatibleoutcomes(est)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><h2><a class="nav-anchor" id="Confidence-intervals-1" href="#Confidence-intervals-1">Confidence intervals</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.ConfidenceInterval" href="#BinaryTwoStageDesigns.ConfidenceInterval"><code>BinaryTwoStageDesigns.ConfidenceInterval</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConfidenceInterval</code></pre><p>Abstract base type for all confidence interval types.</p></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.limits-Union{Tuple{BinaryTwoStageDesigns.ConfidenceInterval,T,T}, Tuple{T}} where T&lt;:Integer" href="#BinaryTwoStageDesigns.limits-Union{Tuple{BinaryTwoStageDesigns.ConfidenceInterval,T,T}, Tuple{T}} where T&lt;:Integer"><code>BinaryTwoStageDesigns.limits</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">limits{T&lt;:Integer}(ci::ConfidenceInterval, x1::T, x2::T)</code></pre><p>Return the confidence interval limits for observed x1 and x2.</p><p><strong>Parameters</strong></p><table><tr><th>Parameter</th><th>Description</th></tr><tr><td>ci</td><td>any ConfidenceInterval object</td></tr><tr><td>x1</td><td>stage-one responses</td></tr><tr><td>x2</td><td>stage-two responses</td></tr></table><p><strong>Return Value</strong></p><p>Two element Real vector of limits [lower, upper].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ss = SimpleSampleSpace(10:25, 100, n2min = 5)
julia&gt; interimsamplesize(ss)
julia&gt; design = getoptimaldesign(15, params, solver = Gurobi.GurobiSolver())
julia&gt; est = MLE(design)
julia&gt; ci = ClopperPearsonConfidenceInterval(est, confidence = .9)
julia&gt; limits(ci, 0, 0)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.coverage-Union{Tuple{BinaryTwoStageDesigns.ConfidenceInterval,T}, Tuple{T}} where T&lt;:Real" href="#BinaryTwoStageDesigns.coverage-Union{Tuple{BinaryTwoStageDesigns.ConfidenceInterval,T}, Tuple{T}} where T&lt;:Real"><code>BinaryTwoStageDesigns.coverage</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">coverage(ci::ConfidenceInterval, p::T; orientation::String = &quot;overall&quot;) where {T&lt;:Real}</code></pre><p>Return coverage of given confidence interval and response rate <code>p</code>.</p><p><strong>Parameters</strong></p><table><tr><th>Parameter</th><th>Description</th></tr><tr><td>ci</td><td>any ConfidenceInterval object</td></tr><tr><td>p</td><td>response rate</td></tr><tr><td>orientation</td><td>string indicating the coverage type - &quot;overall&quot;, &quot;lower&quot;, or &quot;upper&quot;</td></tr></table><p><strong>Return Value</strong></p><p>Coverage probability given <code>p</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ss = SimpleSampleSpace(10:25, 100, n2min = 5)
julia&gt; interimsamplesize(ss)
julia&gt; design = getoptimaldesign(15, params, solver = Gurobi.GurobiSolver())
julia&gt; est = MLE(design)
julia&gt; ci = ClopperPearsonConfidenceInterval(est, confidence = .9)
julia&gt; coverage(ci, .5)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.meanwidth-Union{Tuple{BinaryTwoStageDesigns.ConfidenceInterval,T}, Tuple{T}} where T&lt;:Real" href="#BinaryTwoStageDesigns.meanwidth-Union{Tuple{BinaryTwoStageDesigns.ConfidenceInterval,T}, Tuple{T}} where T&lt;:Real"><code>BinaryTwoStageDesigns.meanwidth</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">meanwidth(ci::ConfidenceInterval, p::T) where {T&lt;:Real}</code></pre><p>Mean width of given confidence interval and response rate <code>p</code>.</p><p><strong>Parameters</strong></p><table><tr><th>Parameter</th><th>Description</th></tr><tr><td>ci</td><td>any ConfidenceInterval object</td></tr><tr><td>p</td><td>response rate</td></tr></table><p><strong>Return Value</strong></p><p>Mean width given <code>p</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ss = SimpleSampleSpace(10:25, 100, n2min = 5)
julia&gt; interimsamplesize(ss)
julia&gt; design = getoptimaldesign(15, params, solver = Gurobi.GurobiSolver())
julia&gt; est = MLE(design)
julia&gt; ci = ClopperPearsonConfidenceInterval(est, confidence = .9)
julia&gt; meanwidth(ci, .5)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.meaninterval-Union{Tuple{BinaryTwoStageDesigns.ConfidenceInterval,T}, Tuple{T}} where T&lt;:Real" href="#BinaryTwoStageDesigns.meaninterval-Union{Tuple{BinaryTwoStageDesigns.ConfidenceInterval,T}, Tuple{T}} where T&lt;:Real"><code>BinaryTwoStageDesigns.meaninterval</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">meaninterval(ci::ConfidenceInterval, p::T) where {T&lt;:Real}</code></pre><p>Mean interval (average limits) of given confidence interval and response rate <code>p</code>.</p><p><strong>Parameters</strong></p><table><tr><th>Parameter</th><th>Description</th></tr><tr><td>ci</td><td>any ConfidenceInterval object</td></tr><tr><td>p</td><td>response rate</td></tr></table><p><strong>Return Value</strong></p><p>Mean interval given <code>p</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ss = SimpleSampleSpace(10:25, 100, n2min = 5)
julia&gt; interimsamplesize(ss)
julia&gt; design = getoptimaldesign(15, params, solver = Gurobi.GurobiSolver())
julia&gt; est = MLE(design)
julia&gt; ci = ClopperPearsonConfidenceInterval(est, confidence = .9)
julia&gt; meaninterval(ci, .5)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.findinconsistencies-Union{Tuple{BinaryTwoStageDesigns.ConfidenceInterval,T}, Tuple{T}} where T&lt;:Real" href="#BinaryTwoStageDesigns.findinconsistencies-Union{Tuple{BinaryTwoStageDesigns.ConfidenceInterval,T}, Tuple{T}} where T&lt;:Real"><code>BinaryTwoStageDesigns.findinconsistencies</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findinconsistencies(ci::ConfidenceInterval, p0::T) where {T&lt;:Real}</code></pre><p>Return outcomes where the confidence interval contradicts the designs test decision.</p><p><strong>Parameters</strong></p><table><tr><th>Parameter</th><th>Description</th></tr><tr><td>ci</td><td>any ConfidenceInterval object</td></tr><tr><td>p</td><td>response rate</td></tr></table><p><strong>Return Value</strong></p><p>Mean interval given <code>p</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ss = SimpleSampleSpace(10:25, 100, n2min = 5)
julia&gt; interimsamplesize(ss)
julia&gt; design = getoptimaldesign(15, params, solver = Gurobi.GurobiSolver())
julia&gt; est = MLE(design)
julia&gt; ci = ClopperPearsonConfidenceInterval(est, confidence = .9)
julia&gt; findinconsistencies(ci)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><h3><a class="nav-anchor" id="Naive-Clopper-Pearson-confidence-interval-1" href="#Naive-Clopper-Pearson-confidence-interval-1">Naive Clopper-Pearson confidence interval</a></h3><pre><code class="language-none">CPInterval{T&lt;:Real}(
  design::Design;
  confidence::T = .9
)</code></pre><h3><a class="nav-anchor" id="Clopper-Pearson-confidence-interval-1" href="#Clopper-Pearson-confidence-interval-1">Clopper-Pearson confidence interval</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.ECPInterval-Union{Tuple{BinaryTwoStageDesigns.Estimator}, Tuple{T}} where T&lt;:Real" href="#BinaryTwoStageDesigns.ECPInterval-Union{Tuple{BinaryTwoStageDesigns.Estimator}, Tuple{T}} where T&lt;:Real"><code>BinaryTwoStageDesigns.ECPInterval</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ECPInterval{T&lt;:Real}(
  estimator::Estimator;
  confidence::T = .9,
  k::Integer = 1001
)</code></pre><p>Exact Clopper-Pearson type confidence interval based on ordering induced by <code>estimator</code>.</p><p><strong>Parameters</strong></p><table><tr><th>Parameter</th><th>Description</th></tr><tr><td>estimator</td><td>estimator object defining the sample space ordering</td></tr><tr><td>confidence</td><td>confidence level of the interval</td></tr><tr><td>k</td><td>number of equally spaced grid-points for invertign the test</td></tr></table></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><h3><a class="nav-anchor" id="Minimum-mean-width-confidence-interval-1" href="#Minimum-mean-width-confidence-interval-1">Minimum mean width confidence interval</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BinaryTwoStageDesigns.MMWInterval-Union{Tuple{TE,TR,Function,MathProgBase.SolverInterface.AbstractMathProgSolver}, Tuple{TE}, Tuple{TR}} where TR&lt;:Real where TE&lt;:BinaryTwoStageDesigns.Estimator" href="#BinaryTwoStageDesigns.MMWInterval-Union{Tuple{TE,TR,Function,MathProgBase.SolverInterface.AbstractMathProgSolver}, Tuple{TE}, Tuple{TR}} where TR&lt;:Real where TE&lt;:BinaryTwoStageDesigns.Estimator"><code>BinaryTwoStageDesigns.MMWInterval</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">MMWInterval(
  estimator::TE,
  rho0::TR,
  prior::Function,
  solver::MathProgBase.AbstractMathProgSolver;
  confidence::TR = 0.9,
  ngrid::Integer = 100
) where {TE&lt;:Estimator,TR&lt;:Real}</code></pre><p>Exact confidence interval based on ordering induced by <code>estimator</code> minimizing the expected squared width with respect to weight function <code>prior(p::Real)</code>.</p><p><strong>Parameters</strong></p><table><tr><th>Parameter</th><th>Description</th></tr><tr><td>estimator</td><td>estimator object defining the sample space ordering</td></tr><tr><td>rho0</td><td>upper boundary of null hypothesis</td></tr><tr><td>confidence</td><td>confidence level of the interval</td></tr><tr><td>solver</td><td>MathProgBase solver used for optimization, must support quadratic expressions</td></tr><tr><td>ngrid</td><td>number of equally spaced grid-points on which to check coverage</td></tr></table></div><a class="source-link" target="_blank" href="https://github.com/imbi-heidelberg/BinaryTwoStageDesigns/b23be3c64d63d2d22da8eeb4aea5c004ea549f7a">source</a></section><footer><hr/><a class="previous" href="optimal_designs.html"><span class="direction">Previous</span><span class="title">Finding Optimal Designs</span></a></footer></article></body></html>
